### Local key helper on Windows

On Windows, a Local key helper is a COM class. A COM interface that the local key helper implements is TBD (working name for this document is ILocalKeyHelper)

#### Deployment of a 3rd party local key helper.

Local key helpers will be deployed using registry.

The base registry key is:

```
[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\<Company>\<Browser>\LocalKeyHelperList]
```

i.e.

```
[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Edge\LocalKeyHelperList]

[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Google\Chrome\LocalKeyHelperList]
```

Every local key helper has a child key in the above registry key. The entry for the local key is a registry key with the name equals to the local key helper id, the default value stores activation ID, prefixed by an activation scheme.

```
[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\<Company>\<Browser>\LocalKeyHelperList\<LocalKeyHelperId>]
@="<Scheme>:<API activation ID>"
```

Here is example:

```
[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Edge\LocalKeyHelperList\login.contoso.com]
@="progid:App.Component.1.0"

[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Edge\LocalKeyHelperList\login.fabrikam.com]
@="clsid:3AD05D77-6885-4BAF-A727-D30690A2A28A"
```

Currently the supported schemes are:

1. clsid: \<GUID\> - CLSID of a COM class that implements the Local Key Helper.
2. progid:\<ProgId string\> - [a programic identifier](https://learn.microsoft.com/en-us/windows/win32/com/-progid--key) of the local key helper.

This scheme can be extended by other schemes in future.
The local key helper registry key can have extra values, which we can use for in future.

Here is a visual example how Local key helper is organized:

![Local key helper registry key](./images/keyhelper-reg.png)

When the browser needs to communicate with a local key helper. It uses its ID to locate the registry key, then reads the default value of this registry key and activates the object by the activation scheme (CLSID or ProgId according to the document). After activation it queries ILocalKeyHelper interface and invokes corresponding methods.

#### Well-known local key helpers on Windows

A well-known local key helper list on Windows is a list of helperId to clsid, that either harcoded or predefined in the browser settings.

### **Attestation Service**:

A service that is responsible for verifying the device registration and providing the attestation to the IdP. The attestation service can be owned by the IdP or a third party. Before defining the attestation service, let us get familiar with the building blocks of binding and proof of binding.

There are three artifacts that are generated during/after the device registration process, which are used to prove the device binding. These are the _binding key_, the _attestation key_, and the _binding statement_.

#### **Binding Key**:

A _binding key_ is an asymmetric key pair that is used to bind an auth cookie.It is identified by a key ID and it is the responsibility of the browser to remember which key ID corresponds to which Local Key Helper and to use it for DBSC signatures and key management. As there could be multiple `devices` on a single physical device and or many device registration clients on a single device (mentioned [above](#device-registration-client)), the key mapping is expected to be managed by the Browser and the Local Key Helper.

This **binding key** is the same as defined in the DBSC proposal [here](https://github.com/WICG/dbsc?tab=readme-ov-file#maintaining-a-session) and is expected to be created in a secure enclave (TPM or Keyguard) on the original device. However, please note that in the context of the DBSC proposal, the binding key validation is not guaranteed to be attack free, as it can be generated by malware running on the device. In the context DBSC(E), the binding key is generated during the device registration process, and hence is guaranteed to be attack free if generated in a clean room environment.

#### **Binding Statement**:

Additonal to the binding key, the local key helper also generates a _binding statement_, a statement that asserts the binding key was generated on the same device as the device key. Details on how this statement is issued are out of scope for this document. However, the validation of the binding statement is a key building block of the DBSC(E) protocol.

#### **Attestation Key**

An _attestation key_ is generated during the device registration process and has the following properties:

    1. It signs only the private/other keys that reside in the same secure enclave as the attestation key.
    2. It cannot sign any external payload, or if it signs, it cannot generate an output that can be interpreted as an attestation statement.

Since the attestation key can be uploaded only once to the backend at the moment of device registration, in the clean room, and there is no need to change this key unless the device loses it (Could be due to key rotation or similar operations).

#### **Binding Statement - Generation and Validation**:

The **attestation key**, hence, can be used to attest that the **binding key** belongs to the same device as the attestation key, by signing the public part of the binding key (with the attestation key) and generating an **attestation statement**. Depending on the specific implementation, this **attestation statement** itself can be a **binding statement**, or it can be sent to an attestation service to produce the final binding statement.

The validation of the **binding statement** authenticates the device by using device ID to find the corresponding attestation key. The validation component verifies the **attestation statement**, and it can understand that such a statement cannot be generated, unless the private key resides in the same secure enclave when signed by the **attestation key**. Hence, a valid attestation statement means that both the attestation key and the binding key belong to the same device. The validation component can be part of the attestation service for public local key helpers, or part of an IdP for private local key helper.

This is not the only way to ensure that the binding key and the device key belong to the same device, and having the **attestation key** and the **attestation service** is not mandatory for producing a **binding statement**. That is why the protocol specifics of checking the binding are out of scope for this document. The focus of DBSC(E) is to only establish important properties of the binding statement.

Binding statements can be long-lived or short-lived. If an IdP can perform proof of device, it can use long-lived binding statements based on attestation keys to avoid extra network calls. IdPs that do not perform proof of possession of the device, the ones that use public local key helpers, must use short-lived binding statements to prevent forgery of the binding statement from a different device. To avoid binding statement forgery, a short-lived binding statement must have an embedded nonce sent by the IdP to validate that it is a fresh binding statement.
